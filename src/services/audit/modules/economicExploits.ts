export interface VulnerabilityFinding {
  title: string;
  severity: 'Critical' | 'High' | 'Medium' | 'Low';
  description: string;
  impact: string;
  location: string;
  recommendation: string;
  exploitScenario?: string;
  pocCode?: string;
  economicImpact?: string;
}

export interface EconomicExploitDetector {
  detectFlashLoanOracleManipulation(code: string): VulnerabilityFinding[];
  detectGovernanceFlashVote(code: string): VulnerabilityFinding[];
  detectVaultDonationAttack(code: string): VulnerabilityFinding[];
  detectCrossProtocolExploits(code: string): VulnerabilityFinding[];
  detectMEVSandwichAttacks(code: string): VulnerabilityFinding[];
  detectProxyStorageCollision(code: string): VulnerabilityFinding[];
  detectFeeOnTransferBugs(code: string): VulnerabilityFinding[];
  detectTWAPOracleAttacks(code: string): VulnerabilityFinding[];
  detectLogicalReentrancy(code: string): VulnerabilityFinding[];
  detectForcedEtherInjection(code: string): VulnerabilityFinding[];
  detectReadOnlyReentrancy(code: string): VulnerabilityFinding[];
  detectPermitSignatureReplay(code: string): VulnerabilityFinding[];
  detectBridgeReplay(code: string): VulnerabilityFinding[];
  detectRoundingDrift(code: string): VulnerabilityFinding[];
  detectGriefingSpam(code: string): VulnerabilityFinding[];
  detectEmergencyPauseBypass(code: string): VulnerabilityFinding[];
  detectFlashMintExploits(code: string): VulnerabilityFinding[];
  detectRebaseSnapshotAttacks(code: string): VulnerabilityFinding[];
  detectMulticallDoubleSpend(code: string): VulnerabilityFinding[];
  detectProfitCapBypass(code: string): VulnerabilityFinding[];
  detectFundingRateDrain(code: string): VulnerabilityFinding[];
  detectLeverageBypass(code: string): VulnerabilityFinding[];
  detectLossSocialization(code: string): VulnerabilityFinding[];
  detectBridgeVerifierFlaws(code: string): VulnerabilityFinding[];
  detectArbitraryCallDispatch(code: string): VulnerabilityFinding[];
}

export class EconomicExploitDetectorImpl implements EconomicExploitDetector {
  
  detectFlashLoanOracleManipulation(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for flash loan usage with oracle dependencies
    if (code.includes('flashLoan') || code.includes('FlashLoan')) {
      if (code.includes('oracle') || code.includes('price') || code.includes('getPrice')) {
        findings.push({
          title: 'Flash Loan Oracle Manipulation Risk',
          severity: 'Critical',
          description: 'Contract uses flash loans in conjunction with price oracles, enabling single-transaction price manipulation attacks.',
          impact: 'Attacker can borrow assets, manipulate oracle prices, and drain liquidity pools for profit.',
          location: 'Multiple functions involving flash loans and price feeds',
          recommendation: 'Implement time-weighted average prices (TWAP), use multiple oracles, add flash loan fees, or implement price manipulation detection.',
          exploitScenario: 'Borrow large amount → manipulate DEX price → swap at artificial rate → repay flash loan with profit',
          economicImpact: 'Can drain entire liquidity pools, losses in millions (e.g., Mango Markets $100M+ loss)',
          
pocCode: `
// Attacker contract
function attack() external {
    // 1. Flash loan large amount of token A
    flashLoan(largeAmount);
    
    // 2. Use flash loaned tokens to manipulate price on DEX
    swap(tokenA, tokenB, largeAmount);
    
    // 3. Call victim protocol that uses manipulated price
    victimProtocol.deposit(tokenB, amount);
    
    // 4. Withdraw at inflated price
    victimProtocol.withdraw();
    
    // 5. Repay flash loan
    repayFlashLoan();
}
          `
        });
      }
    }
    
    return findings;
  }

  detectGovernanceFlashVote(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for governance without snapshot protection
    if (code.includes('governance') || code.includes('vote') || code.includes('proposal')) {
      if (code.includes('balanceOf') && !code.includes('snapshot') && !code.includes('checkpoint')) {
        findings.push({
          title: 'Governance Flash-Vote Attack Vulnerability',
          severity: 'Critical',
          description: 'Governance system uses real-time balanceOf without snapshot mechanism, vulnerable to flash-vote attacks.',
          impact: 'Attacker can temporarily inflate voting power to pass malicious proposals.',
          location: 'Governance voting functions',
          recommendation: 'Implement snapshot-based voting or add timelocks for proposal execution.',
          exploitScenario: 'Flash loan governance tokens → vote on malicious proposal → return tokens → proposal passes',
          economicImpact: 'Can lead to protocol takeover, fund drainage (e.g., Beanstalk $182M loss)',
          
pocCode: `
// Attacker contract
function attack() external {
    // 1. Flash loan governance tokens
    governanceToken.flashLoan(largeAmount);
    
    // 2. Vote on malicious proposal
    governance.vote(proposalId, largeAmount);
    
    // 3. Execute proposal immediately (if no timelock)
    governance.execute(proposalId);
    
    // 4. Repay flash loan
    repayFlashLoan();
}
          `
        });
      }
    }
    
    return findings;
  }

  detectVaultDonationAttack(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for ERC4626 vaults with direct transfer capabilities
    if (code.includes('ERC4626') || code.includes('totalAssets') || code.includes('totalSupply')) {
      if (code.includes('transfer') || code.includes('transferFrom')) {
        findings.push({
          title: 'Vault Share Inflation via Donation Attack',
          severity: 'High',
          description: 'ERC4626 vault allows direct token transfers, enabling share price manipulation through donations.',
          impact: 'Attacker can manipulate share prices by donating tokens, diluting other users\' shares.',
          location: 'Vault implementation with direct transfer support',
          recommendation: 'Disable direct transfers to vault contract or implement donation protection mechanisms.',
          exploitScenario: 'Direct transfer tokens to vault → share price dilution → redeem inflated shares',
          economicImpact: 'Can drain vault funds, affects all depositors (multiple $10M+ incidents)',
          
pocCode: `
// Attacker action
function attack() external {
    // 1. Direct transfer underlying tokens to vault
    underlyingToken.transfer(vaultAddress, largeAmount);
    
    // 2. Share price is now inflated: totalAssets / totalSupply
    // 3. Deposit small amount to get shares
    vault.deposit(smallAmount);
    
    // 4. Redeem shares at inflated price
    vault.redeem(sharesReceived);
    
    // Profit = (largeAmount * smallAmount / totalSupply) - smallAmount
}
          `
        });
      }
    }
    
    return findings;
  }

  detectCrossProtocolExploits(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for external protocol calls before state updates
    if (code.includes('external') || code.includes('call')) {
      if (code.includes('state') || code.includes('balance')) {
        findings.push({
          title: 'Cross-Protocol Composability Exploit Risk',
          severity: 'High',
          description: 'Contract makes external calls to other protocols before updating internal state, vulnerable to composability exploits.',
          impact: 'State inconsistencies across protocols can be exploited for profit.',
          location: 'Functions with external calls before state updates',
          recommendation: 'Follow Checks-Effects-Interactions pattern, use reentrancy guards for cross-protocol calls.',
          exploitScenario: 'Manipulate state in Protocol A → call Protocol B → revert to exploit state inconsistency',
          economicImpact: 'Can lead to fund loss through state manipulation (e.g., Ronin $625M hack)',
          
pocCode: `
// Vulnerable pattern
function vulnerableFunction() external {
    // External call before state update
    otherProtocol.doSomething(); // Can reenter and manipulate state
    
    // State update after external call
    userBalance[msg.sender] += amount; // State now inconsistent
}
          `
        });
      }
    }
    
    return findings;
  }

  detectMEVSandwichAttacks(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for time-sensitive operations without protection
    if (code.includes('swap') || code.includes('trade') || code.includes('exchange')) {
      if (!code.includes('deadline') && !code.includes('commit') && !code.includes('reveal')) {
        findings.push({
          title: 'MEV Sandwich Attack Vulnerability',
          severity: 'Medium',
          description: 'Trading operations lack protection against MEV sandwich attacks through transaction ordering.',
          impact: 'Attackers can front-run and back-run trades for profit at user expense.',
          location: 'Swap/trade functions without deadline protection',
          recommendation: 'Add transaction deadlines, use commit-reveal schemes, or implement private mempools.',
          exploitScenario: 'Monitor mempool → front-run large trade → victim trade executes → back-run for profit',
          economicImpact: 'Extracts value from legitimate traders, increases user costs',
          
pocCode: `
// MEV Sandwich Attack
// 1. Attacker sees pending trade: swap(tokenA, tokenB, largeAmount)
// 2. Front-run: swap(tokenB, tokenA, largeAmount) - moves price against victim
// 3. Victim trade executes at worse price
// 4. Back-run: swap(tokenA, tokenB, largeAmount) - profits from price movement
          `
        });
      }
    }
    
    return findings;
  }

  detectProxyStorageCollision(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for upgradeable proxies
    if (code.includes('proxy') || code.includes('upgrade') || code.includes('implementation')) {
      if (code.includes('storage') || code.includes('slot')) {
        findings.push({
          title: 'Proxy Storage Collision on Upgrade Risk',
          severity: 'Critical',
          description: 'Upgradeable proxy implementation may have storage layout conflicts that corrupt critical state variables.',
          impact: 'Upgrades can overwrite important storage slots, leading to complete contract compromise.',
          location: 'Proxy and implementation contracts',
          recommendation: 'Use structured storage patterns, implement storage gap patterns, test upgrades thoroughly.',
          exploitScenario: 'Deploy new implementation with different storage layout → upgrade → critical variables overwritten',
          economicImpact: 'Can lead to total fund loss if owner/admin keys are corrupted',
          
pocCode: `
// Vulnerable storage layout
contract ImplementationV1 {
    address public owner;        // slot 0
    uint256 public totalSupply;  // slot 1
}

contract ImplementationV2 {
    uint256 public totalSupply;  // slot 0 - COLLISION!
    address public owner;        // slot 1 - Now in wrong slot
}

// After upgrade, owner is corrupted, funds locked
          `
        });
      }
    }
    
    return findings;
  }

  detectFeeOnTransferBugs(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for token transfers without balance verification
    if (code.includes('transfer') || code.includes('transferFrom')) {
      if (!code.includes('balanceOf') && code.includes('amount')) {
        findings.push({
          title: 'Fee-on-Transfer Token Accounting Bug',
          severity: 'High',
          description: 'Contract assumes transferred amount equals credited amount, vulnerable to fee-on-transfer tokens.',
          impact: 'Incorrect balance calculations when using tokens that charge transfer fees.',
          location: 'Token transfer and accounting functions',
          recommendation: 'Always check actual balance changes, not transferred amounts.',
          exploitScenario: 'Send fee-on-transfer token → contract credits full amount → actual balance is less',
          economicImpact: 'Can cause accounting errors, fund discrepancies',
          
pocCode: `
// Vulnerable code
function deposit(uint256 amount) external {
    token.transferFrom(msg.sender, address(this), amount);
    userBalance[msg.sender] += amount; // WRONG: assumes full amount received
}

// With fee-on-transfer token (e.g., 1% fee):
// User sends 100 tokens → contract receives 99 tokens
// userBalance += 100, but only 99 tokens held
// Accounting broken!
          `
        });
      }
    }
    
    return findings;
  }

  detectTWAPOracleAttacks(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for TWAP implementations
    if (code.includes('TWAP') || code.includes('timeWeighted') || code.includes('observation')) {
      if (code.includes('window') || code.includes('period')) {
        findings.push({
          title: 'TWAP Oracle Window Attack Vulnerability',
          severity: 'High',
          description: 'Time-weighted average price oracle uses short observation window, vulnerable to brief price manipulation.',
          impact: 'Attacker can manipulate price briefly within window to affect trades.',
          location: 'TWAP oracle implementation',
          recommendation: 'Use longer observation windows, implement manipulation detection, use multiple oracles.',
          exploitScenario: 'Manipulate price briefly → execute trade within TWAP window → revert price',
          economicImpact: 'Can extract value through artificial price movements',
          
pocCode: `
// Vulnerable TWAP with 10-minute window
// Attacker manipulates price for 5 minutes
// Executes trade at manipulated TWAP price
// Price reverts, but trade already executed
          `
        });
      }
    }
    
    return findings;
  }

  detectLogicalReentrancy(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for ERC-777 or callback functions that mutate state
    if (code.includes('ERC777') || code.includes('callback') || code.includes('hook')) {
      if (code.includes('state') || code.includes('balance')) {
        findings.push({
          title: 'Logical Reentrancy via Token Callbacks',
          severity: 'High',
          description: 'ERC-777 tokens or callbacks can trigger reentrancy through token operations that mutate contract state.',
          impact: 'State manipulation through token transfer callbacks.',
          location: 'Token transfer and callback functions',
          recommendation: 'Use reentrancy guards, follow CEI pattern, avoid state changes in callbacks.',
          exploitScenario: 'Token transfer triggers callback → re-enters contract logic → manipulates state',
          economicImpact: 'Can lead to fund drainage through state manipulation',
          
pocCode: `
// ERC-777 callback reentrancy
function tokensReceived(address from, uint256 amount) external {
    // Callback can reenter
    if (msg.sender == token) {
        // State changes here can be exploited
        userBalance[from] += amount; // Can be manipulated
    }
}
          `
        });
      }
    }
    
    return findings;
  }

  detectForcedEtherInjection(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for reliance on address(this).balance
    if (code.includes('address(this).balance') || code.includes('this.balance')) {
      findings.push({
        title: 'Forced Ether Injection via SELFDESTRUCT',
        severity: 'Medium',
        description: 'Contract relies on address(this).balance which can be artificially inflated via selfdestruct.',
        impact: 'Balance manipulation through forced ether injection.',
        location: 'Balance-dependent logic',
        recommendation: 'Track balances internally instead of relying on address balance.',
        exploitScenario: 'Contract selfdestructs sending ether to target → balance artificially inflated',
        economicImpact: 'Can break balance-dependent logic, cause incorrect calculations',
        
pocCode: `
// Vulnerable contract
contract Victim {
    function withdraw() external {
        uint256 balance = address(this).balance; // Can be manipulated
        payable(msg.sender).transfer(balance);
    }
}

// Attacker forces ether injection
contract Attacker {
    function attack() external payable {
        selfdestruct(payable(victimAddress)); // Forces ether to victim
    }
}
        `
      });
    }
    
    return findings;
  }

  detectReadOnlyReentrancy(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for view functions making external calls
    if (code.includes('view') || code.includes('pure')) {
      if (code.includes('call') || code.includes('staticcall') || code.includes('external')) {
        findings.push({
          title: 'Read-Only Reentrancy Vulnerability',
          severity: 'High',
          description: 'View functions make external calls that can change state through reentrancy.',
          impact: 'State inconsistency in read operations leading to incorrect information.',
          location: 'View functions with external calls',
          recommendation: 'Avoid external calls in view functions, use cached values.',
          exploitScenario: 'View function calls external contract → external contract calls back → state changes',
          economicImpact: 'Can provide incorrect price/balance information leading to wrong decisions',
          pocCode: `
// Vulnerable view function
function getBalance() external view returns (uint256) {
    // External call in view function
    return externalContract.getUserBalance(msg.sender); // Can be manipulated
}

// Attacker manipulates external contract state during view call
        `
      });
    }
    }

    return findings;
  }

  detectPermitSignatureReplay(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for permit functions
    if (code.includes('permit') || code.includes('EIP-712') || code.includes('EIP712')) {
      if (!code.includes('nonce') || !code.includes('used')) {
        findings.push({
          title: 'Permit Signature Replay Vulnerability',
          severity: 'High',
          description: 'Permit functions lack proper nonce validation, vulnerable to signature replay attacks.',
          impact: 'Signatures can be reused across different contexts or contracts.',
          location: 'Permit function implementations',
          recommendation: 'Implement proper nonce tracking and domain separation.',
          exploitScenario: 'Extract permit signature → reuse in different contract/context',
          economicImpact: 'Can lead to unauthorized token approvals and fund theft',
          
pocCode: `
// Vulnerable permit without nonce
function permit(address owner, address spender, uint256 amount, bytes memory signature) external {
    // No nonce checking - signature can be replayed
    // Verify signature...
    _approve(owner, spender, amount);
}
          `
        });
      }
    }
    
    return findings;
  }

  detectBridgeReplay(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for bridge message handling
    if (code.includes('bridge') || code.includes('message') || code.includes('cross-chain')) {
      if (!code.includes('nonce') && !code.includes('processed')) {
        findings.push({
          title: 'Bridge Message Replay Vulnerability',
          severity: 'Critical',
          description: 'Bridge accepts messages without nonce or replay protection, vulnerable to message replay across chains.',
          impact: 'Messages can be replayed on different chains or multiple times.',
          location: 'Bridge message processing functions',
          recommendation: 'Implement nonce tracking and message processing status.',
          exploitScenario: 'Intercept bridge message → replay on target chain',
          economicImpact: 'Can lead to duplicate fund transfers (e.g., Nomad $190M loss)',
          
pocCode: `
// Vulnerable bridge message processing
function processMessage(bytes memory message) external {
    // No replay protection
    Message memory msg = decode(message);
    // Process message - can be replayed!
    transferFunds(msg.recipient, msg.amount);
}
          `
        });
      }
    }
    
    return findings;
  }

  detectRoundingDrift(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for repeated mathematical operations
    if (code.includes('mul') || code.includes('div') || code.includes('*') || code.includes('/')) {
      if (code.includes('loop') || code.includes('for') || code.includes('while')) {
        findings.push({
          title: 'Rounding Drift / Precision Loss Vulnerability',
          severity: 'Medium',
          description: 'Repeated mathematical operations with rounding can accumulate precision loss over time.',
          impact: 'Value extraction through accumulated rounding errors in loops.',
          location: 'Mathematical operations in loops',
          recommendation: 'Use higher precision internally, round only on output, implement drift protection.',
          exploitScenario: 'Multiple small operations → accumulated rounding errors → profit extraction',
          economicImpact: 'Can extract value through precision loss accumulation',
          
pocCode: `
// Vulnerable rounding in loop
for (uint256 i = 0; i < iterations; i++) {
    amount = amount * 999 / 1000; // 0.1% fee each time
    // After many iterations, significant loss due to rounding
}
          `
        });
      }
    }
    
    return findings;
  }

  detectGriefingSpam(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for operations that can be cheaply spammed
    if (code.includes('gas') || code.includes('cost') || code.includes('expensive')) {
      if (code.includes('require') || code.includes('revert')) {
        findings.push({
          title: 'Griefing via Spam Attack Vector',
          severity: 'Low',
          description: 'Operations can be spammed at low cost to increase costs for honest users or congest networks.',
          impact: 'Network congestion, increased costs for legitimate operations.',
          location: 'Gas-intensive operations',
          recommendation: 'Implement anti-spam mechanisms, rate limiting, or spam fees.',
          exploitScenario: 'Spam cheap operations to congest network/bridge',
          economicImpact: 'Increases costs for honest users, can DoS systems',
          
pocCode: `
// Vulnerable to spam
function expensiveOperation() external {
    require(heavyComputation()); // Expensive but can be called cheaply
    // Attacker calls this repeatedly to waste network resources
}
          `
        });
      }
    }
    
    return findings;
  }

  detectEmergencyPauseBypass(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for pause mechanisms
    if (code.includes('pause') || code.includes('emergency') || code.includes('circuit')) {
      if (code.includes('onlyOwner') || code.includes('access')) {
        findings.push({
          title: 'Emergency Pause Bypass Vulnerability',
          severity: 'High',
          description: 'Emergency pause mechanisms can potentially be bypassed through alternative code paths.',
          impact: 'Exploitation can continue during emergency situations.',
          location: 'Pause mechanism implementations',
          recommendation: 'Ensure comprehensive pause coverage, test bypass scenarios.',
          exploitScenario: 'Find alternative code paths that bypass pause logic',
          economicImpact: 'Can continue exploitation during emergency response',
          
pocCode: `
// Pause mechanism
modifier whenNotPaused() {
    require(!paused, "Paused");
    _;
}

// Bypass: function without modifier
function bypassWithdraw() external {
    // No pause check - bypasses emergency pause
    payable(msg.sender).transfer(balance);
}
          `
        });
      }
    }
    
    return findings;
  }

  detectFlashMintExploits(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for flash mint implementations
    if (code.includes('flashMint') || code.includes('flashLoan')) {
      if (!code.includes('fee') || !code.includes('premium')) {
        findings.push({
          title: 'Flash-Mint Token Exploit Risk',
          severity: 'High',
          description: 'Flash minting lacks proper validation or fees, vulnerable to infinite token creation.',
          impact: 'Attacker can create infinite tokens through flash minting loops.',
          location: 'Flash mint implementation',
          recommendation: 'Implement flash mint fees, add validation checks, limit mint amounts.',
          exploitScenario: 'Flash mint tokens → use in protocol → repay with minted tokens',
          economicImpact: 'Can create infinite token supply, devalue token',
          
pocCode: `
// Vulnerable flash mint
function flashMint(uint256 amount) external {
    _mint(msg.sender, amount); // No fee, no limit
    
    // User can do anything here
    
    // Repay check
    require(balanceOf(msg.sender) >= amount, "Insufficient balance");
    _burn(msg.sender, amount);
}
          `
        });
      }
    }
    
    return findings;
  }

  detectRebaseSnapshotAttacks(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for rebase tokens with snapshots
    if (code.includes('rebase') || code.includes('elastic')) {
      if (code.includes('snapshot') || code.includes('checkpoint')) {
        findings.push({
          title: 'Rebase Token + Snapshot Timing Attack',
          severity: 'Medium',
          description: 'Rebase tokens combined with snapshot mechanisms vulnerable to timing attacks.',
          impact: 'Balances can be manipulated at snapshot time through rebase timing.',
          location: 'Rebase token and snapshot implementations',
          recommendation: 'Implement snapshot timing protections, use TWAP for snapshots.',
          exploitScenario: 'Time rebase to coincide with snapshot → inflated balances',
          economicImpact: 'Can manipulate voting power or reward distributions',
          
pocCode: `
// Rebase token with snapshot
function snapshot() external {
    userBalanceAtSnapshot[msg.sender] = balanceOf(msg.sender); // Can be manipulated by timing rebase
}

// Attacker times rebase to inflate balance at snapshot time
          `
        });
      }
    }
    
    return findings;
  }

  detectMulticallDoubleSpend(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for multicall implementations
    if (code.includes('multicall') || code.includes('batch')) {
      if (code.includes('allowance') || code.includes('approve')) {
        findings.push({
          title: 'Multicall Double-Spend Allowance Vulnerability',
          severity: 'High',
          description: 'Multicall allows double-spending of allowances within single transaction.',
          impact: 'Spend allowances multiple times in single transaction.',
          location: 'Multicall and allowance functions',
          recommendation: 'Implement allowance tracking per multicall, use unique nonces.',
          exploitScenario: 'Batch calls that reuse same allowance',
          economicImpact: 'Can drain approved funds multiple times',
          
pocCode: `
// Vulnerable multicall
function multicall(bytes[] calldata data) external {
    for (uint256 i = 0; i < data.length; i++) {
        (bool success,) = address(this).call(data[i]);
        require(success);
    }
}

// Attacker can include multiple calls that spend same allowance
          `
        });
      }
    }
    
    return findings;
  }

  detectProfitCapBypass(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for profit/loss caps
    if (code.includes('cap') || code.includes('limit') || code.includes('max')) {
      if (code.includes('partial') || code.includes('close')) {
        findings.push({
          title: 'Profit Cap Bypass via Partial Operations',
          severity: 'Medium',
          description: 'Global profit/loss caps can be bypassed through multiple partial operations.',
          impact: 'Users can exceed intended position limits.',
          location: 'Position management with caps',
          recommendation: 'Implement global limits that account for partial operations.',
          exploitScenario: 'Multiple partial closes to bypass caps',
          economicImpact: 'Can exceed risk limits, lead to protocol insolvency',
          
pocCode: `
// Vulnerable cap system
uint256 public maxProfit = 100 ether;

// Partial close bypasses cap
function partialClose(uint256 amount) external {
    uint256 profit = calculateProfit(amount);
    require(profit <= maxProfit, "Exceeds cap"); // Only checks partial amount
    
    // Attacker calls multiple times to exceed total cap
}
          `
        });
      }
    }
    
    return findings;
  }

  detectFundingRateDrain(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for funding rate calculations
    if (code.includes('funding') || code.includes('rate')) {
      if (code.includes('position') || code.includes('collateral')) {
        findings.push({
          title: 'Funding Rate Drain via Spam Positions',
          severity: 'Medium',
          description: 'Funding rate calculations vulnerable to manipulation through spam positions.',
          impact: 'Attackers can skew funding rates for profit.',
          location: 'Funding rate calculation logic',
          recommendation: 'Implement spam-resistant funding calculations, add minimum position sizes.',
          exploitScenario: 'Open/close many small positions to skew funding calculations',
          economicImpact: 'Can manipulate funding costs, extract value from other traders',
          
pocCode: `
// Vulnerable funding rate
function calculateFundingRate() public view returns (int256) {
    int256 totalLong = getTotalLongPositions();
    int256 totalShort = getTotalShortPositions();
    
    // Attacker opens many tiny positions to skew ratio
    return (totalLong - totalShort) * rateMultiplier / totalPositions;
}
          `
        });
      }
    }
    
    return findings;
  }

  detectLeverageBypass(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for leverage limits
    if (code.includes('leverage') || code.includes('margin')) {
      if (code.includes('protocol') || code.includes('cross')) {
        findings.push({
          title: 'Leverage Clamping Bypass via Composability',
          severity: 'High',
          description: 'Leverage limits can be bypassed through cross-protocol composability.',
          impact: 'Users can take unlimited effective leverage.',
          location: 'Leverage and margin management',
          recommendation: 'Implement cross-protocol leverage tracking, add composability guards.',
          exploitScenario: 'Use multiple protocols to bypass individual limits',
          economicImpact: 'Can lead to unlimited leverage, protocol insolvency',
          
pocCode: `
// Protocol A: max leverage 5x
// Protocol B: max leverage 5x
// Combined: 25x effective leverage

// Attacker uses Protocol A to leverage into Protocol B
function bypassLeverage() external {
    // Deposit into Protocol A with 5x leverage
    protocolA.leverageDeposit(amount, 5);
    
    // Use leveraged funds as collateral in Protocol B with 5x leverage
    protocolB.leverageDeposit(leveragedAmount, 5);
    
    // Now has 25x effective leverage
}
          `
        });
      }
    }
    
    return findings;
  }

  detectLossSocialization(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for loss distribution mechanisms
    if (code.includes('socialize') || code.includes('loss') || code.includes('distribution')) {
      if (code.includes('token') || code.includes('inflation')) {
        findings.push({
          title: 'Token Inflation via Loss Socialization',
          severity: 'High',
          description: 'Loss distribution mechanism leads to token inflation, diluting holder value.',
          impact: 'Token value dilution through loss socialization.',
          location: 'Loss distribution and token mechanisms',
          recommendation: 'Implement sustainable loss absorption, avoid token dilution.',
          exploitScenario: 'Cause losses → socialize to token holders → profit from dilution',
          economicImpact: 'Dilutes token value, affects all holders',
          
pocCode: `
// Loss socialization via token minting
function socializeLoss(uint256 lossAmount) external {
    // Mint new tokens to cover loss
    _mint(address(this), lossAmount); // Dilutes existing holders
    
    // Distribute to affected users
    distributeTokens(lossAmount);
}
          `
        });
      }
    }
    
    return findings;
  }

  detectBridgeVerifierFlaws(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for bridge verifiers
    if (code.includes('verify') || code.includes('proof') || code.includes('bridge')) {
      if (code.includes('logic') || code.includes('complex')) {
        findings.push({
          title: 'Bridge Verifier Logic Flaws',
          severity: 'Critical',
          description: 'Bridge message verifiers contain logical flaws that can be exploited.',
          impact: 'Invalid messages can pass verification.',
          location: 'Bridge verification logic',
          recommendation: 'Simplify verification logic, implement comprehensive testing.',
          exploitScenario: 'Exploit logical flaws in verification → pass invalid messages',
          economicImpact: 'Can lead to invalid cross-chain transfers',
          
pocCode: `
// Complex verification logic with flaw
function verifyMessage(bytes memory message, bytes memory proof) external returns (bool) {
    // Complex logic that might have edge cases
    if (condition1 && condition2 || condition3) {
        // Potential logic flaw here
        return true;
    }
    return false;
}
          `
        });
      }
    }
    
    return findings;
  }

  detectArbitraryCallDispatch(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for call dispatch mechanisms
    if (code.includes('dispatch') || code.includes('delegate') || code.includes('call')) {
      if (code.includes('arbitrary') || !code.includes('whitelist')) {
        findings.push({
          title: 'Arbitrary Call Dispatch in Gateways',
          severity: 'Critical',
          description: 'Cross-chain gateways allow arbitrary call dispatch without proper validation.',
          impact: 'Execute arbitrary actions cross-chain.',
          location: 'Cross-chain call dispatch functions',
          recommendation: 'Implement call whitelisting, validate call targets and data.',
          exploitScenario: 'Craft messages for arbitrary contract calls',
          economicImpact: 'Can execute arbitrary actions, lead to fund theft',
          
pocCode: `
// Vulnerable call dispatch
function dispatchCall(address target, bytes memory data) external {
    // No validation of target or data
    (bool success,) = target.call(data); // Arbitrary calls!
    require(success);
}
          `
        });
      }
    }
    
    return findings;
  }
}

export const economicExploitDetector = new EconomicExploitDetectorImpl();
