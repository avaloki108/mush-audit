  title: string;
  severity: 'Critical' | 'High' | 'Medium' | 'Low';
  description: string;
  impact: string;
  location: string;
  recommendation: string;
  exploitScenario?: string;
  pocCode?: string;
  economicImpact?: string;
}

export interface EconomicExploitDetector {
  detectFlashLoanOracleManipulation(code: string): VulnerabilityFinding[];
  detectGovernanceFlashVote(code: string): VulnerabilityFinding[];
  detectVaultDonationAttack(code: string): VulnerabilityFinding[];
  detectCrossProtocolExploits(code: string): VulnerabilityFinding[];
  detectMEVSandwichAttacks(code: string): VulnerabilityFinding[];
  detectProxyStorageCollision(code: string): VulnerabilityFinding[];
  detectFeeOnTransferBugs(code: string): VulnerabilityFinding[];
  detectTWAPOracleAttacks(code: string): VulnerabilityFinding[];
  detectLogicalReentrancy(code: string): VulnerabilityFinding[];
  detectForcedEtherInjection(code: string): VulnerabilityFinding[];
  detectReadOnlyReentrancy(code: string): VulnerabilityFinding[];
  detectPermitSignatureReplay(code: string): VulnerabilityFinding[];
  detectBridgeReplay(code: string): VulnerabilityFinding[];
  detectRoundingDrift(code: string): VulnerabilityFinding[];
  detectGriefingSpam(code: string): VulnerabilityFinding[];
  detectEmergencyPauseBypass(code: string): VulnerabilityFinding[];
  detectFlashMintExploits(code: string): VulnerabilityFinding[];
  detectRebaseSnapshotAttacks(code: string): VulnerabilityFinding[];
  detectMulticallDoubleSpend(code: string): VulnerabilityFinding[];
  detectProfitCapBypass(code: string): VulnerabilityFinding[];
  detectFundingRateDrain(code: string): VulnerabilityFinding[];
  detectLeverageBypass(code: string): VulnerabilityFinding[];
  detectLossSocialization(code: string): VulnerabilityFinding[];
  detectBridgeVerifierFlaws(code: string): VulnerabilityFinding[];
  detectArbitraryCallDispatch(code: string): VulnerabilityFinding[];
}

export class EconomicExploitDetectorImpl implements EconomicExploitDetector {
  
  detectFlashLoanOracleManipulation(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for flash loan usage with oracle dependencies
    if (code.includes('flashLoan') || code.includes('FlashLoan')) {
      if (code.includes('oracle') || code.includes('price') || code.includes('getPrice')) {
        findings.push({
          title: 'Flash Loan Oracle Manipulation Risk',
          severity: 'Critical',
          description: 'Contract uses flash loans in conjunction with price oracles, enabling single-transaction price manipulation attacks.',
          impact: 'Attacker can borrow assets, manipulate oracle prices, and drain liquidity pools for profit.',
          location: 'Multiple functions involving flash loans and price feeds',
          recommendation: 'Implement time-weighted average prices (TWAP), use multiple oracles, add flash loan fees, or implement price manipulation detection.',
          exploitScenario: 'Borrow large amount → manipulate DEX price → swap at artificial rate → repay flash loan with profit',
          economicImpact: 'Can drain entire liquidity pools, losses in millions (e.g., Mango Markets $100M+ loss)',
          
pocCode: `
// Attacker contract
function attack() external {
    // 1. Flash loan large amount of token A
    flashLoan(largeAmount);
    
    // 2. Use flash loaned tokens to manipulate price on DEX
    swap(tokenA, tokenB, largeAmount);
    
    // 3. Call victim protocol that uses manipulated price
    victimProtocol.deposit(tokenB, amount);
    
    // 4. Withdraw at inflated price
    victimProtocol.withdraw();
    
    // 5. Repay flash loan
    repayFlashLoan();
}
          `
        });
      }
    }
    
    return findings;
  }

  detectGovernanceFlashVote(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for governance without snapshot protection
    if (code.includes('governance') || code.includes('vote') || code.includes('proposal')) {
      if (code.includes('balanceOf') && !code.includes('snapshot') && !code.includes('checkpoint')) {
        findings.push({
          title: 'Governance Flash-Vote Attack Vulnerability',
          severity: 'Critical',
          description: 'Governance system uses real-time balanceOf without snapshot mechanism, vulnerable to flash-vote attacks.',
          impact: 'Attacker can temporarily inflate voting power to pass malicious proposals.',
          location: 'Governance voting functions',
          recommendation: 'Implement snapshot-based voting or add timelocks for proposal execution.',
          exploitScenario: 'Flash loan governance tokens → vote on malicious proposal → return tokens → proposal passes',
          economicImpact: 'Can lead to protocol takeover, fund drainage (e.g., Beanstalk $182M loss)',
          
pocCode: `
// Attacker contract
function attack() external {
    // 1. Flash loan governance tokens
    governanceToken.flashLoan(largeAmount);
    
    // 2. Vote on malicious proposal
    governance.vote(proposalId, largeAmount);
    
    // 3. Execute proposal immediately (if no timelock)
    governance.execute(proposalId);
    
    // 4. Repay flash loan
    repayFlashLoan();
}
          `
        });
      }
    }
    
    return findings;
  }

  detectVaultDonationAttack(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for ERC4626 vaults with direct transfer capabilities
    if (code.includes('ERC4626') || code.includes('totalAssets') || code.includes('totalSupply')) {
      if (code.includes('transfer') || code.includes('transferFrom')) {
        findings.push({
          title: 'Vault Share Inflation via Donation Attack',
          severity: 'High',
          description: 'ERC4626 vault allows direct token transfers, enabling share price manipulation through donations.',
          impact: 'Attacker can manipulate share prices by donating tokens, diluting other users\' shares.',
          location: 'Vault implementation with direct transfer support',
          recommendation: 'Disable direct transfers to vault contract or implement donation protection mechanisms.',
          exploitScenario: 'Direct transfer tokens to vault → share price dilution → redeem inflated shares',
          economicImpact: 'Can drain vault funds, affects all depositors (multiple $10M+ incidents)',
          
pocCode: `
// Attacker action
function attack() external {
    // 1. Direct transfer underlying tokens to vault
    underlyingToken.transfer(vaultAddress, largeAmount);
    
    // 2. Share price is now inflated: totalAssets / totalSupply
    // 3. Deposit small amount to get shares
    vault.deposit(smallAmount);
    
    // 4. Redeem shares at inflated price
    vault.redeem(sharesReceived);
    
    // Profit = (largeAmount * smallAmount / totalSupply) - smallAmount
}
          `
        });
      }
    }
    
    return findings;
  }

  detectCrossProtocolExploits(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for external protocol calls before state updates
    if (code.includes('external') || code.includes('call')) {
      if (code.includes('state') || code.includes('balance')) {
        findings.push({
          title: 'Cross-Protocol Composability Exploit Risk',
          severity: 'High',
          description: 'Contract makes external calls to other protocols before updating internal state, vulnerable to composability exploits.',
          impact: 'State inconsistencies across protocols can be exploited for profit.',
          location: 'Functions with external calls before state updates',
          recommendation: 'Follow Checks-Effects-Interactions pattern, use reentrancy guards for cross-protocol calls.',
          exploitScenario: 'Manipulate state in Protocol A → call Protocol B → revert to exploit state inconsistency',
          economicImpact: 'Can lead to fund loss through state manipulation (e.g., Ronin $625M hack)',
          
pocCode: `
// Vulnerable pattern
function vulnerableFunction() external {
    // External call before state update
    otherProtocol.doSomething(); // Can reenter and manipulate state
    
    // State update after external call
    userBalance[msg.sender] += amount; // State now inconsistent
}
          `
        });
      }
    }
    
    return findings;
  }

  detectMEVSandwichAttacks(code: string): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    
    // Check for time-sensitive operations without protection
    if (code.includes('swap') || code.includes('trade') || code.includes('exchange')) {